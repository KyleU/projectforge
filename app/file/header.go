package file

import (
	"strings"

	"go.uber.org/zap"
)

//const HeaderContent = "Code generated by Project Forge, see https://projectforge.dev for details."
const HeaderContent = "Code generated by projectforge.dev"

func ContainsHeader(s string) bool {
	return strings.Contains(s, HeaderContent)
}

// nolint
func contentWithHeader(t Type, header string, c string, logger *zap.SugaredLogger) string {
	if strings.Contains(c, "$PF_IGNORE$") {
		return c
	}
	switch t.Key {
	case TypeBat.Key:
		return "REM " + header + "\n" + c
	case TypeConf.Key:
		return c
	case TypeCSS.Key:
		return "/* " + header + " */\n" + c
	case TypeDocker.Key:
		return "# " + header + "\n" + c
	case TypeEntitlements.Key:
		return c
	case TypeGitIgnore.Key:
		return c
	case TypeGo.Key:
		return "// " + header + "\n" + c
	case TypeGoMod.Key:
		return "// " + header + "\n" + c
	case TypeGradle.Key:
		return c
	case TypeHCL.Key:
		return "# " + header + "\n" + c
	case TypeHTML.Key:
		return "<!-- " + header + " -->\n" + c
	case TypeIcons.Key:
		return c
	case TypeIgnore.Key:
		return c
	case TypeJavaScript.Key:
		return "// " + header + "\n" + c
	case TypeJSON.Key:
		return c
	case TypeKotlin.Key:
		return "// " + header + "\n" + c
	case TypeMakefile.Key:
		return "# " + header + "\n" + c
	case TypeMarkdown.Key:
		return "<!--- " + header + " -->\n" + c
	case TypePBXProject.Key:
		return c
	case TypePList.Key:
		return c
	case TypeProperties.Key:
		return c
	case TypeShell.Key:
		return secondLine(c, "# "+header)
	case TypeSVG.Key:
		return c
	case TypeSwift.Key:
		return "// " + header + "\n" + c
	case TypeText.Key:
		return "# " + header + "\n" + c
	case TypeTypeScript.Key:
		return "// " + header + "\n" + c
	case TypeXML.Key:
		if strings.HasPrefix(c, "<?") {
			return secondLine(c, "<!-- "+header+" -->")
		}
		return "<!-- " + header + " -->\n" + c
	case TypeYAML.Key:
		return "# " + header + "\n" + c
	default:
		logger.Warnf("unhandled header for file type [%s]", t.Title)
		return c
	}
}

func secondLine(content string, rplc string) string {
	idx := strings.Index(content, "\n")
	if idx == -1 {
		return content
	}
	return content[0:idx] + "\n" + rplc + content[idx:]
}
